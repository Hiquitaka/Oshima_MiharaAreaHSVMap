String[][]pre;
float[]el=new float[2000*1500];
float[]sa=new float[1998*1498];
float max=0;
float min;
float[][]oa,ob,oc,od,oe,of,og,oh,oA,oB,oC,oD,oE,oF,oG,oH;
float[]O1,O2,O3,O4,O5,O6,O7,O8,P1,P2,P3,P4,P5,P6,P7,P8;
void setup(){
  String lines[]=loadStrings("oshimamihara_2m.txt");
  int rowlength=0;
  for(int i=0;i<lines.length;i++){
    String[]row=split(lines[i]," ");
    if(row.length>rowlength){
      rowlength=row.length;
    }
  }
  println(lines.length,rowlength);//行と列の数を確認
  pre=new String[lines.length][rowlength];
  for(int i=0;i<lines.length;i++){
    String[]temp=new String[lines.length];
    temp=split(lines[i], " ");
    for(int j=0;j<temp.length;j++){
      pre[i][j]=temp[j];
    }
  }
  println(pre[6][0],pre[1505][1999]);//最初と最後の標高データを表示
  for(int x=0;x<2000;x++){
    for(int y=0;y<1500;y++){
      el[2000*y+x]=float(pre[y+6][x]);
    }
  }
  println(el[0],el[2000*1499+1999]);//前述の標高データと同じであるか確認
  for(int x=0;x<2000;x++){
    for(int y=0;y<1500;y++){
      if(el[2000*y+x]<0){
        el[2000*y+x]=-1;//標高値0未満地点全てを標高値-1に変更
      }
    }
  }
  for(int x=1;x<1999;x++){
    for(int y=1;y<1499;y++){
      sa[1998*(y-1)+x-1]=180*atan(sqrt(sq((el[2000*(y-1)+x+1]+2*el[2000*y+x+1]+el[2000*(y+1)+x+1]-el[2000*(y-1)+x-1]-2*el[2000*y+x-1]-el[2000*(y+1)+x-1])/(4*(2+2)))+sq((el[2000*(y+1)+x+1]+2*el[2000*(y+1)+x]+el[2000*(y+1)+x-1]-el[2000*(y-1)+x-1]-2*el[2000*(y-1)+x]-el[2000*(y-1)+x+1])/(4*(2+2)))))/PI;
    }
  }
  for(int x=10;x<1990;x++){
    for(int y=10;y<1490;y++){
      if(max<el[2000*y+x]){
        max=el[2000*y+x];
      }
    }
  }
  println(max);//最大標高値を提示
  float m1=max;
  max=0;
  for(int x=9;x<1989;x++){
    for(int y=9;y<1489;y++){
      if(max<sa[1998*y+x]){
        max=sa[1998*y+x];
      }
    }
  }
  println(max);//最大傾斜角を提示
  float m2=max;
  max=0;
  oa=new float[10][1980*1480];
  oc=new float[10][1980*1480];
  oe=new float[10][1980*1480];
  og=new float[10][1980*1480];
  oA=new float[10][1980*1480];
  oC=new float[10][1980*1480];
  oE=new float[10][1980*1480];
  oG=new float[10][1980*1480];
  ob=new float[int(10/sqrt(2))][1980*1480];
  od=new float[int(10/sqrt(2))][1980*1480];
  of=new float[int(10/sqrt(2))][1980*1480];
  oh=new float[int(10/sqrt(2))][1980*1480];
  oB=new float[int(10/sqrt(2))][1980*1480];
  oD=new float[int(10/sqrt(2))][1980*1480];
  oF=new float[int(10/sqrt(2))][1980*1480];
  oH=new float[int(10/sqrt(2))][1980*1480];
  O1=new float[1980*1480];
  O2=new float[1980*1480];
  O3=new float[1980*1480];
  O4=new float[1980*1480];
  O5=new float[1980*1480];
  O6=new float[1980*1480];
  O7=new float[1980*1480];
  O8=new float[1980*1480];
  P1=new float[1980*1480];
  P2=new float[1980*1480];
  P3=new float[1980*1480];
  P4=new float[1980*1480];
  P5=new float[1980*1480];
  P6=new float[1980*1480];
  P7=new float[1980*1480];
  P8=new float[1980*1480];
  float[]onta=new float[1980*1480];
  for(int x=10;x<1990;x++){
    for(int y=10;y<1490;y++){
      for(int j=0;j<10;j++){
        if(el[2000*y+x+j+1]-el[2000*y+x]==0){
          oa[j][1980*(y-10)+x-10]=90;
        }else{
          oa[j][1980*(y-10)+x-10]=180*atan(2*(j+1)/(el[2000*y+x+j+1]-el[2000*y+x]))/PI;
        }
        oA[j][1980*(y-10)+x-10]=180-oa[j][1980*(y-10)+x-10];
        if(oa[j][1980*(y-10)+x-10]<0){
          oa[j][1980*(y-10)+x-10]=90-oa[j][1980*(y-10)+x-10];
          oA[j][1980*(y-10)+x-10]=180-oa[j][1980*(y-10)+x-10];
        }
        if(el[2000*(y+j+1)+x]-el[2000*y+x]==0){
          oc[j][1980*(y-10)+x-10]=90;
        }else{
          oc[j][1980*(y-10)+x-10]=180*atan(2*(j+1)/(el[2000*(y+j+1)+x]-el[2000*y+x]))/PI;
        }
        oC[j][1980*(y-10)+x-10]=180-oc[j][1980*(y-10)+x-10];
        if(oc[j][1980*(y-10)+x-10]<0){
          oc[j][1980*(y-10)+x-10]=90-oc[j][1980*(y-10)+x-10];
          oC[j][1980*(y-10)+x-10]=180-oc[j][1980*(y-10)+x-10];
        }
        if(el[2000*y+x-j-1]-el[2000*y+x]==0){
          oe[j][1980*(y-10)+x-10]=90;
        }else{
          oe[j][1980*(y-10)+x-10]=180*atan(2*(j+1)/(el[2000*y+x-j-1]-el[2000*y+x]))/PI;
        }
        oE[j][1980*(y-10)+x-10]=180-oe[j][1980*(y-10)+x-10];
        if(oe[j][1980*(y-10)+x-10]<0){
          oe[j][1980*(y-10)+x-10]=90-oe[j][1980*(y-10)+x-10];
          oE[j][1980*(y-10)+x-10]=180-oe[j][1980*(y-10)+x-10];
        }
        if(el[2000*(y-j-1)+x]-el[2000*y+x]==0){
          og[j][1980*(y-10)+x-10]=90;
        }else{
          og[j][1980*(y-10)+x-10]=180*atan(2*(j+1)/(el[2000*(y-j-1)+x]-el[2000*y+x]))/PI;
        }
        oG[j][1980*(y-10)+x-10]=180-og[j][1980*(y-10)+x-10];
        if(og[j][1980*(y-10)+x-10]<0){
          og[j][1980*(y-10)+x-10]=90-og[j][1980*(y-10)+x-10];
          oG[j][1980*(y-10)+x-10]=180-og[j][1980*(y-10)+x-10];
        }
      }
      for(int j=0;j<int(10/sqrt(2));j++){
        if(el[2000*(y+j+1)+x+j+1]-el[2000*y+x]==0){
          ob[j][1980*(y-10)+x-10]=90;
        }else{
          ob[j][1980*(y-10)+x-10]=180*atan(2*sqrt(2)*(j+1)/(el[2000*(y+j+1)+x+j+1]-el[2000*y+x]))/PI;
        }
        oB[j][1980*(y-10)+x-10]=180-ob[j][1980*(y-10)+x-10];
        if(ob[j][1980*(y-10)+x-10]<0){
          ob[j][1980*(y-10)+x-10]=90-ob[j][1980*(y-10)+x-10];
          oB[j][1980*(y-10)+x-10]=180-ob[j][1980*(y-10)+x-10];
        }
        if(el[2000*(y+j+1)+x-j-1]-el[2000*y+x]==0){
          od[j][1980*(y-10)+x-10]=90;
        }else{
          od[j][1980*(y-10)+x-10]=180*atan(2*sqrt(2)*(j+1)/(el[2000*(y+j+1)+x-j-1]-el[2000*y+x]))/PI;
        }
        oD[j][1980*(y-10)+x-10]=180-od[j][1980*(y-10)+x-10];
        if(od[j][1980*(y-10)+x-10]<0){
          od[j][1980*(y-10)+x-10]=90-od[j][1980*(y-10)+x-10];
          oD[j][1980*(y-10)+x-10]=180-od[j][1980*(y-10)+x-10];
        }
        if(el[2000*(y-j-1)+x-j-1]-el[2000*y+x]==0){
          of[j][1980*(y-10)+x-10]=90;
        }else{
          of[j][1980*(y-10)+x-10]=180*atan(2*sqrt(2)*(j+1)/(el[2000*(y-j-1)+x-j-1]-el[2000*y+x]))/PI;
        }
        oF[j][1980*(y-10)+x-10]=180-of[j][1980*(y-10)+x-10];
        if(of[j][1980*(y-10)+x-10]<0){
          of[j][1980*(y-10)+x-10]=90-of[j][1980*(y-10)+x-10];
          oF[j][1980*(y-10)+x-10]=180-of[j][1980*(y-10)+x-10];
        }
        if(el[2000*(y-j-1)+x+j+1]-el[2000*y+x]==0){
          oh[j][1980*(y-10)+x-10]=90;
        }else{
          oh[j][1980*(y-10)+x-10]=180*atan(2*sqrt(2)*(j+1)/(el[2000*(y-j-1)+x+j+1]-el[2000*y+x]))/PI;
        }
        oH[j][1980*(y-10)+x-10]=180-oh[j][1980*(y-10)+x-10];
        if(oh[j][1980*(y-10)+x-10]<0){
          oh[j][1980*(y-10)+x-10]=90-oh[j][1980*(y-10)+x-10];
          oH[j][1980*(y-10)+x-10]=180-oh[j][1980*(y-10)+x-10];
        }
      }
      O1[1980*(y-10)+x-10]=oa[0][1980*(y-10)+x-10];
      O2[1980*(y-10)+x-10]=ob[0][1980*(y-10)+x-10];
      O3[1980*(y-10)+x-10]=oc[0][1980*(y-10)+x-10];
      O4[1980*(y-10)+x-10]=od[0][1980*(y-10)+x-10];
      O5[1980*(y-10)+x-10]=oe[0][1980*(y-10)+x-10];
      O6[1980*(y-10)+x-10]=of[0][1980*(y-10)+x-10];
      O7[1980*(y-10)+x-10]=og[0][1980*(y-10)+x-10];
      O8[1980*(y-10)+x-10]=oh[0][1980*(y-10)+x-10];
      P1[1980*(y-10)+x-10]=oA[0][1980*(y-10)+x-10];
      P2[1980*(y-10)+x-10]=oB[0][1980*(y-10)+x-10];
      P3[1980*(y-10)+x-10]=oC[0][1980*(y-10)+x-10];
      P4[1980*(y-10)+x-10]=oD[0][1980*(y-10)+x-10];
      P5[1980*(y-10)+x-10]=oE[0][1980*(y-10)+x-10];
      P6[1980*(y-10)+x-10]=oF[0][1980*(y-10)+x-10];
      P7[1980*(y-10)+x-10]=oG[0][1980*(y-10)+x-10];
      P8[1980*(y-10)+x-10]=oH[0][1980*(y-10)+x-10];
      for(int j=0;j<10;j++){
        if(oa[j][1980*(y-10)+x-10]<O1[1980*(y-10)+x-10]){
          O1[1980*(y-10)+x-10]=oa[j][1980*(y-10)+x-10];
        }
        if(oc[j][1980*(y-10)+x-10]<O3[1980*(y-10)+x-10]){
          O3[1980*(y-10)+x-10]=oc[j][1980*(y-10)+x-10];
        }
        if(oe[j][1980*(y-10)+x-10]<O5[1980*(y-10)+x-10]){
          O5[1980*(y-10)+x-10]=oe[j][1980*(y-10)+x-10];
        }
        if(og[j][1980*(y-10)+x-10]<O7[1980*(y-10)+x-10]){
          O7[1980*(y-10)+x-10]=og[j][1980*(y-10)+x-10];
        }
        if(oA[j][1980*(y-10)+x-10]<P1[1980*(y-10)+x-10]){
          P1[1980*(y-10)+x-10]=oA[j][1980*(y-10)+x-10];
        }
        if(oC[j][1980*(y-10)+x-10]<P3[1980*(y-10)+x-10]){
          P3[1980*(y-10)+x-10]=oC[j][1980*(y-10)+x-10];
        }
        if(oE[j][1980*(y-10)+x-10]<P5[1980*(y-10)+x-10]){
          P5[1980*(y-10)+x-10]=oE[j][1980*(y-10)+x-10];
        }
        if(oG[j][1980*(y-10)+x-10]<P7[1980*(y-10)+x-10]){
          P7[1980*(y-10)+x-10]=oG[j][1980*(y-10)+x-10];
        }
      }
      for(int j=0;j<int(10/sqrt(2));j++){
        if(ob[j][1980*(y-10)+x-10]<O2[1980*(y-10)+x-10]){
          O2[1980*(y-10)+x-10]=ob[j][1980*(y-10)+x-10];
        }
        if(od[j][1980*(y-10)+x-10]<O4[1980*(y-10)+x-10]){
          O4[1980*(y-10)+x-10]=od[j][1980*(y-10)+x-10];
        }
        if(of[j][1980*(y-10)+x-10]<O6[1980*(y-10)+x-10]){
          O6[1980*(y-10)+x-10]=of[j][1980*(y-10)+x-10];
        }
        if(oh[j][1980*(y-10)+x-10]<O8[1980*(y-10)+x-10]){
          O8[1980*(y-10)+x-10]=oh[j][1980*(y-10)+x-10];
        }
        if(oB[j][1980*(y-10)+x-10]<P2[1980*(y-10)+x-10]){
          P2[1980*(y-10)+x-10]=oB[j][1980*(y-10)+x-10];
        }
        if(oD[j][1980*(y-10)+x-10]<P4[1980*(y-10)+x-10]){
          P4[1980*(y-10)+x-10]=oD[j][1980*(y-10)+x-10];
        }
        if(oF[j][1980*(y-10)+x-10]<P6[1980*(y-10)+x-10]){
          P6[1980*(y-10)+x-10]=oF[j][1980*(y-10)+x-10];
        }
        if(oH[j][1980*(y-10)+x-10]<P8[1980*(y-10)+x-10]){
          P8[1980*(y-10)+x-10]=oH[j][1980*(y-10)+x-10];
        }
      }
    }
  }
  for(int x=0;x<1980;x++){
    for(int y=0;y<1480;y++){
      onta[1980*y+x]=((O1[1980*y+x]+O2[1980*y+x]+O3[1980*y+x]+O4[1980*y+x]+O5[1980*y+x]+O6[1980*y+x]+O7[1980*y+x]+O8[1980*y+x])-(P1[1980*y+x]+P2[1980*y+x]+P3[1980*y+x]+P4[1980*y+x]+P5[1980*y+x]+P6[1980*y+x]+P7[1980*y+x]+P8[1980*y+x]))/16;
      if(max<onta[1980*y+x]){
        max=onta[1980*y+x];
      }
    }
  }
  min=max;
  for(int x=0;x<1980;x++){
    for(int y=0;y<1480;y++){
      if(min>onta[1980*y+x]){
        min=onta[1980*y+x];
      }
    }
  }
  println(min,max);//尾根谷度の最小値と最大値を提示
  size(1980,1480);
  noStroke();
  noSmooth();
  colorMode(HSB,m1,m2*2,180);
  for(int x=0;x<1980;x++){
    for(int y=0;y<1480;y++){
      stroke(m1-el[2000*(y+10)+x+10],2*sa[1998*(y+9)+x+9],90+onta[1980*y+x]);
      point(x,y);
    }
  }
  save("Oshima_mihara.png");//大島三原山付近のHSV色空間を活用した擬似的に立体表現された地形図が完成する。
  }
}
